
    <html>
    <head>
        <meta charset="utf-8">
        <style>
            body { font-family: 'Segoe UI', sans-serif; padding: 2em; line-height: 1.6; }
            h1, h2, h3 { color: #222; }
            code { background-color: #f4f4f4; padding: 2px 4px; border-radius: 4px; }
            pre { background: #f0f0f0; padding: 10px; overflow-x: auto; }
            table { border-collapse: collapse; width: 100%; margin: 20px 0; }
            th, td { border: 1px solid #ccc; padding: 8px; text-align: left; }
            a { color: #0366d6; text-decoration: none; }
        </style>
        <title>Writeup</title>
    </head>
    <body>
        <p><a href="http://localhost:8000/html/" style="text-decoration: none;">‚Üê Back</a></p>
<h1>Design Patterns in Modern Python and JavaScript</h1>
<p>Design patterns are general, reusable solutions to common software design problems. They provide a standard terminology and best practices for writing clean, maintainable, and scalable code. This write-up explores some core design patterns and how they are implemented in <strong>Python</strong> and <strong>JavaScript</strong>.</p>
<h2>1. <strong>Singleton Pattern</strong></h2>
<p>Ensures a class has only one instance and provides a global point of access.</p>
<h3>Python:</h3>
<pre><code class="language-python">class Singleton:
    _instance = None

    def __new__(cls):
        if not cls._instance:
            cls._instance = super(Singleton, cls).__new__(cls)
        return cls._instance
</code></pre>
<h3>JavaScript:</h3>
<pre><code class="language-javascript">const Singleton = (function () {
  let instance;
  function createInstance() {
    return { id: Date.now() };
  }
  return {
    getInstance: function () {
      if (!instance) instance = createInstance();
      return instance;
    }
  };
})();
</code></pre>
<h2>3. <strong>Observer Pattern</strong></h2>
<p>Defines a one-to-many dependency so that when one object changes state, all its dependents are notified.</p>
<h3>Python:</h3>
<pre><code class="language-python">class Subject:
    def __init__(self):
        self._observers = []

    def notify(self, message):
        for obs in self._observers:
            obs.update(message)

    def subscribe(self, observer):
        self._observers.append(observer)

class Observer:
    def update(self, message):
        print(f&quot;Received: {message}&quot;)
</code></pre>
<h3>JavaScript:</h3>
<pre><code class="language-javascript">class Subject {
  constructor() {
    this.observers = [];
  }

  subscribe(observer) {
    this.observers.push(observer);
  }

  notify(msg) {
    this.observers.forEach(observer =&gt; observer(msg));
  }
}
</code></pre>
<h2>5. <strong>Strategy Pattern</strong></h2>
<p>Defines a family of algorithms, encapsulates each one, and makes them interchangeable.</p>
<h3>Python:</h3>
<pre><code class="language-python">class Strategy:
    def execute(self, data):
        pass

class ConcreteStrategyA(Strategy):
    def execute(self, data):
        return sorted(data)

class Context:
    def __init__(self, strategy):
        self.strategy = strategy

    def do_something(self, data):
        return self.strategy.execute(data)
</code></pre>
<h3>JavaScript:</h3>
<pre><code class="language-javascript">class StrategyA {
  execute(data) {
    return data.sort();
  }
}

class Context {
  constructor(strategy) {
    this.strategy = strategy;
  }

  executeStrategy(data) {
    return this.strategy.execute(data);
  }
}
</code></pre>
<h2>Conclusion</h2>
<p>Understanding and applying design patterns in Python and JavaScript empowers developers to write robust, scalable, and cleaner applications. Whether you're developing backend APIs, frontend interfaces, or microservices, these patterns help align your codebase with proven software engineering practices.</p>
    </body>
    </html>
    